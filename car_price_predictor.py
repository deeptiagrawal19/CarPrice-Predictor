# -*- coding: utf-8 -*-
"""CAR Price Predictor

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q0_BC90tOlA8pmptSGWa2bxr5o13lsYG

## <div style='text-align: center;'> Introduction </div>

### Context
* We are given a dataset containing information of the sale of more than 1000 used cars
* The dataset consists of 10 columns and 1435 rows.
* To predict the price of a used car, a model is required which factors in all the variables from the dataset.

***

<a id='collection'></a>
## <div style='text-align: center;'>1. Collecting and Understanding the Dataset</div>

#### Importing relevant libraries and modules

* Importing Pandas for Data Handling.
* Importing Seaborn and Matplotlib for data Visualisation.
"""

# Data processing, CSV file I/O (e.g. pd.read_csv)
import pandas as pd

# Data Visualisation
import seaborn as sns
import matplotlib.pyplot as plt

"""#### Observing and Understanding the dataset

First the `CarSales.csv` file is stored in the dataframe for further working.
"""

df=pd.read_csv('/content/CarSales.csv',index_col=0,na_values=['??',"????"])
df

"""All the unique values in the categorical features `Age, MetColor, Automatic and Doors` are extracted."""

print("Unique values of FuelType:",df['FuelType'].unique(),
    "\nUnique values of MetColor:",df['MetColor'].unique(),
    "\nUnique values of Automatic:",df['Automatic'].unique(),
    "\nUnique values of Doors:",df['Doors'].unique())

"""##### Observations:

* Number of Features: `10`
* Target Feature: `Price` - Selling price of car ($)
* Numerical Features:
    * `Age` - Age of car in Years.
    * `KM` - Distance driven in Kms
    * `HP` - Power of Engine
    * `CC` - Volume of Engine
    * `Weight` - Weight in Kgs
* Categorical Features:
    * `MetColor` - Metallic Paint = 1,Non-Metallic Paint = 0
    * `Automatic` - Automatic = 1,Manual = 0
    * `FuelType` - Petrol, Diesel, CNG
* Ordinal Features:
    * `Doors` - No. of doors = 2,3,4,5 *(Multiple values are in form of words instead of numbers)*
"""

df.describe()

df.isnull().sum()

"""##### Observations:
* `Age`, `FuelType` and `MetColor` have to be carefully imputated as they have a large number of null values.
* `KM` and `HP` can be imputated with more ease as they have a low number of null values.

***

<a id='cleaning'></a>
## <div style='text-align: center;'> 2. Cleaning and Visualising the Dataset </div>

### Feature Cleaning and Univariate Analysis

#### 1. Age

By visualising `Age` we can choose the method of imputation and whether to divide the feature.
"""

pal=['#222831','#00ADB5','#FF8C32','#DDDDDD','#EEEEEE']

fig=plt.figure(figsize=(18,4))
gs=fig.add_gridspec(1,3)
gs.update(wspace=0.3)
ax0=fig.add_subplot(gs[0,0])
ax1=fig.add_subplot(gs[0,1])
ax2=fig.add_subplot(gs[0,2])

ax0.grid(color='#001B48', linestyle=':', axis='x', zorder=0,  dashes=(1,3))
ax1.grid(color='#001B48', linestyle=':', axis='y', zorder=0, dashes=(1,3))
ax2.grid(color='#001B48', linestyle=':', axis='y', zorder=0, dashes=(1,3))

ax0=sns.kdeplot(ax=ax0,data=df,x='Age',y='Price',fill=True,color='#24a7ad')
ax1=sns.boxplot(ax=ax1,data=df,x='Age',color='#24a7ad')
ax2=sns.scatterplot(ax=ax2,data=df,x='Age',y='Price',color='#24a7ad')

"""##### Observations:
* Through Boxplot we understand that more than 50% of cars had their `Age` between 42 and 69.
* The DensityPlot and ScatterPlot show that although a large number of cars had their `Age` below 60 an unspecified age may very well be closest to 60.
* Therefore it's reasonable to replace the missing values of `Age` with Median instead of Mean.
"""

df['Age'].fillna(df['Age'].median(),inplace=True)
df.head()

"""##### Observation:
* The ScatterPlot shows that Price decreases with `Age` hence Age-Bands can be created so that cars with a similar age can be grouped in a single band.
* It's feasible to create bands based on the assumption that small changes in `Age` don't have a reasonable effect on Price.
* Also we don't observe sudden jumps or falls in `Price` with respect to `Age` in the HistPlot thus supporting the decision of creating AgeBands.
"""

df['AgeBand']=pd.cut(df['Age'],bins=5)
uniques=df['AgeBand'].unique()
print("AgeBands created:")
for i in uniques:
    print(i)

"""Now we can replace each element of `Age` by a weight according to it's respective AgeBand."""

df.loc[df['Age'] <= 16.8,'Age'] = 1
df.loc[(df['Age'] > 16.8) & (df['Age'] <= 32.6),'Age'] = 2
df.loc[(df['Age'] > 32.6) & (df['Age'] <= 48.4),'Age'] = 3
df.loc[(df['Age'] > 48.4) & (df['Age'] <= 64.2),'Age'] = 4
df.loc[(df['Age'] > 64.2) & (df['Age'] <= 80.0),'Age'] = 5
df=df.drop(['AgeBand'],axis=1)

fig=plt.figure(figsize=(4,4))
gs=fig.add_gridspec(1,1)
ax0=fig.add_subplot(gs[0,0])

ax0.grid(color='#001B48', linestyle=':', axis='y', zorder=0,  dashes=(1,3))
ax0=sns.stripplot(ax=ax0,data=df,x='Age',y='Price',color='#24a7ad')

"""#### 2. KMs

Through this step we can choose how to imputate and whether to divide or drop the `KM` feature.
"""

fig=plt.figure(figsize=(18,6))
gs = fig.add_gridspec(1,3)
gs.update(wspace=0.3,hspace=0.15)

ax0=fig.add_subplot(gs[0,0])
ax1=fig.add_subplot(gs[0,1])
ax2=fig.add_subplot(gs[0,2])

ax0.grid(color='#001B48', linestyle=':', axis='x', zorder=0, dashes=(1,3))
ax1.grid(color='#001B48', linestyle=':', axis='y', zorder=0, dashes=(1,3))
ax2.grid(color='#001B48', linestyle=':', axis='x', zorder=0, dashes=(1,3))

ax0=sns.boxplot (ax=ax0, data=df, x='KM', color='#24a7ad')
ax1=sns.scatterplot(ax=ax1, data=df, x='KM',y='Price', color='#24a7ad')
ax2=sns.kdeplot(ax=ax2, data=df, x='KM',y='Price',fill=True, color='#24a7ad')

"""##### Observations:
* The ScatterPlot and Density-Plot shows the majority of distribution of `KM` is around the Mean.
* The BoxPlot shows that mean and median are very close to each other.
* Thus it is established that both, the mean as well as the median can effectively represent the missing values.
* Therefore, replacing the null values in `KM` by it's Mean is as effective as replacing them by it's Median.
* Here it's unnecessary to create bands of cars with similar distance driven as there are high differences in `Price` for cars with similar values of `KM`.
"""

df['KM'].fillna(df['KM'].mean(),inplace=True)

"""#### 3. FuelType

As FuelType has a lot of null values the primary objective is to identify the method of imputation.
"""

fig=plt.figure(figsize=(12,6))
gs = fig.add_gridspec(1,2)
gs.update(wspace=0.3,hspace=0.15)

ax0=fig.add_subplot(gs[0,0])
ax1=fig.add_subplot(gs[0,1])

ax0.grid(color='#001B48', linestyle=':', axis='x', zorder=0,  dashes=(1,3))
ax1.grid(color='#001B48', linestyle=':', axis='y', zorder=0, dashes=(1,3))

ax0=sns.countplot(ax=ax0,data=df,x='FuelType',palette=pal)
ax1=sns.stripplot(ax=ax1,data=df,x='Price',y='FuelType',palette=pal)

"""##### Observation:
* Being a categorical dataset, it can be seen than any null value is most likely to be the mode of the distribution.
* Hence the null values are filled by the mode i.e `Petrol`.
"""

df['FuelType'].fillna(df['FuelType'].mode()[0],inplace=True)

"""#### 4. HP

Now we look at the distribution of HP to further understand how to fill the null values and whether to divide the data or not.
"""

fig=plt.figure(figsize=(12,6))
gs = fig.add_gridspec(1,2)
gs.update(wspace=0.2,hspace=0.15)

ax0=fig.add_subplot(gs[0,0])
ax1=fig.add_subplot(gs[0,1])

ax0.grid(color='#001B48', linestyle=':', axis='y', zorder=0, dashes=(1,3))
ax1.grid(color='#001B48', linestyle=':', axis='x', zorder=0, dashes=(1,3))

ax0=sns.histplot(ax=ax0,data=df['HP'], bins=6, color='#24a7ad')
ax1=sns.scatterplot(ax=ax1,data=df,x='HP',y='Price', color='#24a7ad')

"""##### Observation:
* It is observed that the mean of HP would not properly represent the missing values as:
    * It is distributed very evenly in a large area between 40 and 110.
    * This may result in the null values being misrepresented as a less-likely value.
* Therefore the null values are filled with the median of the distribution to minimise the error.
* We can also create groups of cars with similar HP as multiple cars with similar power are more likely to have the same selling price.
"""

df['HP'].fillna(df['HP'].median(),inplace=True)
df['HPBand']=pd.cut(df['HP'],bins=6)
uniques=df['HPBand'].unique()
print("HP Bands:")
for i in uniques:
    print(i)

"""* Now we create 4 different bands of HP using these boundary values.
* The final band will get a weight of 6 as it's the 6th band while band 4 and 5 contain no elements.
"""

df.loc[(df['HP']>=68.877) & (df['HP']<=89.5),'HP']=1
df.loc[(df['HP']> 89.5) & (df['HP'] <=110.0),'HP']=2
df.loc[(df['HP']> 110.0) & (df['HP']<=130.5),'HP']=3
df.loc[(df['HP']>= 171.5) & (df['HP']<=192.0),'HP']=6
df=df.drop('HPBand',axis=1)

fig=plt.figure(figsize=(10,5))
gs = fig.add_gridspec(1,2)
gs.update(wspace=0.2,hspace=0.15)

ax0=fig.add_subplot(gs[0,0])
ax1=fig.add_subplot(gs[0,1])

ax0=sns.scatterplot(ax=ax0,data=df,x='HP',y='Price', color='#24a7ad')
ax1=sns.countplot(ax=ax1,data=df,x='HP', color='#24a7ad')

"""#### 5. MetColor

Now we visualise `MetColor` to choose our method of feature imputation.
"""

fig=plt.figure(figsize=(12,6))
gs = fig.add_gridspec(1,2)
gs.update(wspace=0.3,hspace=0.15)

ax0=fig.add_subplot(gs[0,0])
ax1=fig.add_subplot(gs[0,1])

ax0.grid(color='#001B48', linestyle=':', axis='y', zorder=0,  dashes=(1,3))
ax1.grid(color='#001B48', linestyle=':', axis='y', zorder=0, dashes=(1,3))

ax0=sns.countplot(ax=ax0,data=df,x='MetColor',color='#24a7ad')
ax1=sns.stripplot(ax=ax1,data=df,x='MetColor',y='Price',color='#24a7ad')

"""##### Observation:
* The mode of the distribution is 1 i.e Metallic Colour.
* Further it can be seen from the Strip-Plot that both categories have little difference between prices.
* Thus it's feasible to replace the null values with 1 owing to a very low difference in prices.
"""

df['MetColor'].fillna(df['MetColor'].mode()[0],inplace=True)
df.isnull().sum()

"""#### 6. Doors

Although the feature `Doors` has no null value, it still contains multiple elements which have the number of doors in words. Therefore these words must be converted to numbers.
"""

df['Doors']=df['Doors'].replace('three','3')
df['Doors']=df['Doors'].replace('four','4')
df['Doors']=df['Doors'].replace('five','5')
print(df['Doors'].unique())

fig=plt.figure(figsize=(12,6))
gs = fig.add_gridspec(1,2)
gs.update(wspace=0.2)

ax0=fig.add_subplot(gs[0,0])
ax1=fig.add_subplot(gs[0,1])

ax0.grid(color='#001B48', linestyle=':', axis='y', zorder=0, dashes=(1,3))
ax1.grid(color='#001B48', linestyle=':', axis='y', zorder=0, dashes=(1,3))

ax0=sns.histplot(ax=ax0,data=df['Doors'], bins=6, color='#24a7ad')
ax1=sns.stripplot(ax=ax1,data=df,x='Doors',y='Price', color='#24a7ad')

"""#### 7. CC and Weight

Both these features don't contain any null values so we visualise them to see their distribution according to `Price`.
"""

fig=plt.figure(figsize=(12,6))
gs = fig.add_gridspec(1,2)
gs.update(wspace=0.2)

ax0=fig.add_subplot(gs[0,0])
ax1=fig.add_subplot(gs[0,1])

ax0.grid(color='#001B48', linestyle=':', axis='x', zorder=0, dashes=(1,3))
ax1.grid(color='#001B48', linestyle=':', axis='x', zorder=0, dashes=(1,3))

ax0=sns.histplot(ax=ax0,data=df,x='CC',y='Price', color='#24a7ad')
ax1=sns.kdeplot(ax=ax1,data=df,x='Weight',y='Price',fill=True, color='#24a7ad')

"""##### Observation:
* The feature `CC` can be divided into 8 classes as there are a large number of elements which have the same `CC`.
"""

df['CCClass']=pd.cut(df['CC'],bins=8)
uniques=df['CCClass'].unique()
print("CC Class intervals:")
for i in uniques:
    print(i)

"""* Now we create 8 different bands of CC using these boundary values.
* The bands 3 and 5 contain no elements and thus will be skipped.
"""

df.loc[(df['CC']>1299.3) & (df['CC']<=1387.5),'CC']=1
df.loc[(df['CC']> 1387.5) & (df['CC'] <=1475.0),'CC']=2
df.loc[(df['CC']> 1562.5) & (df['CC']<=1650.0),'CC']=4
df.loc[(df['CC']> 1737.5) & (df['CC']<=1825.0),'CC']=6
df.loc[(df['CC']> 1825.0) & (df['CC']<=1912.5),'CC']=7
df.loc[(df['CC']> 1912.5) & (df['CC']<=2000.0),'CC']=8

df=df.drop('CCClass',axis=1)

fig=plt.figure(figsize=(10,5))
gs = fig.add_gridspec(1,2)
gs.update(wspace=0.2,hspace=0.15)

ax0=fig.add_subplot(gs[0,0])
ax1=fig.add_subplot(gs[0,1])

ax0=sns.stripplot(ax=ax0,data=df,x='CC',y='Price', color='#24a7ad')
ax1=sns.countplot(ax=ax1,data=df,x='CC', color='#24a7ad')

"""##### Observation:
* Older cars tend to have a higher `CC` and lower `HP`.
* Heavier cars have higher `CC` as well as `HP`
"""